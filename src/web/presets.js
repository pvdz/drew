var PRESETS = {
  "JavaScript": {
    "name": "JavaScript",
    "lang": "js",
    "repeatMode": "after",
    "curryTokens": "curry-no",
    "tokenMode": "object",
    "verboseMode": "verbose-med",
    "query": "{`if` | `while`}       :: find a token whose entire value is `if` or `while`\n  {PAREN_PAIR}=,0      :: skip the parens and pass the closing paren as first param to callback\n  (~ [IS_NEWLINE])=2,3 :: skip tokens until the next newline\n  {`{`}=,1             :: pass on the open curly bracket\n\n            ",
    "args": "parenStop, curlyOpen, whiteStart, whiteStop",
    "callback": "document.querySelector('#debug').value += 'callback called with '+arguments.length+' arguments\\n\\n';\n\nparenStop.value += ' {';\ncurlyOpen.value = '';\nwhiteStart.value = '';\nwhiteStop.value = '';\n            ",
    "input": "if (foo)\n{\n  bar;\n}\n\nwhile (have)\n{\n  weird()\n}\n            ",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // \"Shadows\" constants. Use Drew syntax.\n\n  IS_BLACK: '!WHITE', // see constants\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  CRLF: '`\\\\x0A\\\\x0D`',\n  PS: '`\\\\u2028`',\n  LS: '`\\\\u2029`',\n  IS_NEWLINE: 'LF | CR | CRLF | PS | LS', // you can recurse\n\n  // the rest of the macros serve just as examples\n\n  SPACE: '` `',\n  TAB: '`\\t`',\n\n  COMMA: '`,`',\n  PLUS: '`+`',\n  MIN: '`-`',\n  MINUS: '`-`',\n  DASH: '`-`',\n  IS: '`=`',\n  SEMI: '`;`',\n  CURLY_OPEN: '`{`',\n  CURLY_CLOSE: '`}`',\n  PAREN_OPEN: '`(`',\n  PAREN_CLOSE: '`)`',\n  SQUARE_OPEN: '`[`',\n  SQUARE_CLOSE: '`]`',\n\n  SEMIASI: 'SEMI|ASI',\n\n  // skip from current curly to after the next (group because param assignments are a problem otherwise)\n  CURLY_PAIR: '(CURLY_OPEN & JUMP_TO_RHC)',\n  SQUARE_PAIR: '(SQUARE_OPEN & JUMP_TO_RHS)',\n  PAREN_PAIR: '(PAREN_OPEN & JUMP_TO_RHP)',\n\n  BREAK: '`break`',\n  CASE: '`case`',\n  CATCH: '`catch`',\n  CONTINUE: '`continue`',\n  DEBUGGER: '`debugger`',\n  DEFAULT: '`default`',\n  DO: '`do`',\n  ELSE: '`else`',\n  FINALLY: '`finally`',\n  FOR: '`for`',\n  FUNCTION: '`function`',\n  IF: '`if`',\n  RETURN: '`return`',\n  SWITCH: '`switch`',\n  TRY: '`try`',\n  THROW: '`throw`',\n  VAR: '`var`',\n  WHILE: '`while`',\n  WITH: '`with`',\n  STATEMENT_KEYWORD: 'BREAK | CASE | CONTINUE | DEBUGGER|  DEFAULT | DO | FOR | FUNCTION | IF | RETURN | SWITCH | TRY | THROW | VAR | WHILE | WITH',\n})\n            ",
    "constants": "({\n  // Same as macros but with arbitrary JS\n  // First are used by Drew internally.\n\n  WHITE: 'current().type === Par.WHITE',\n  IS_NEWLINE: 'current().value === \\'\\\\n\\' || current().value === \\'\\\\r\\' || current().value === \\'\\\\r\\\\n\\'', // there are more but pfsj\n\n  // the rest of the macros serve just as examples\n\n  // token type name vars (as governed and exposed by zeparser)\n  STRING: 'type(Par.STRING)',\n  NUMBER: 'type(Par.NUMBER)',\n  REGEX: 'type(Par.REGEX)',\n  PUNCTUATOR: 'type(Par.PUNCTUATOR)',\n  IDENTIFIER: 'type(Par.IDENTIFIER)',\n  EOF: 'type(Par.EOF)',\n  ASI: 'type(Par.ASI)',\n  ERROR: 'type(Par.ERROR)',\n  COMMENT: 'type(Par.WHITE) && value()[0] === \"/\"',\n\n  // custom zeparser hacks\n\n  STATEMENT_START: 'token().statementStart',\n  STATEMENT: 'token().statementStart && (index = token().lastStatementToken.white)',\n\n  // skip from current curly to after the next\n  JUMP_TO_RHC: 'current().rhc && seekTo(current().rhc.white)',\n  JUMP_TO_RHS: 'current().rhs && seekTo(current().white)',\n  JUMP_TO_RHP: 'current().rhp && seekTo(current().rhp.white)',\n\n  KEYWORD: 'token().isKeyword',\n\n  // for test cases\n  PASS: 'true',\n  FAIL: 'false',\n  DEBUG: '!function(){debugger;}'\n})\n            "
  },
  "PlainText": {
    "name": "PlainText",
    "lang": "txt",
    "repeatMode": "after",
    "curryTokens": "curry-yes",
    "tokenMode": "index",
    "verboseMode": "verbose-med",
    "query": ":: this is a partial and naive example of translating \"pseudo\" md to html\n\n: the query matches one of three things;\n\n( : this group matches headers\n\n  ^{`#`}+ = _hashes, hashes_ :: match lines starting with a hash and\n                             :: assigns the range of consecutive hashes\n                             :: to '_hashes' and 'hashes_'\n                             :: the callback receives an object with\n                             :: these property names because of that\n\n  [` ` | `\\t`]*              :: skip tabs and spaces between hashes \n                             :: and content\n\n  ~=_h1, h1_ $               :: ~ will skip until $ matches, which is \n                             :: end of line/file. the range being \n                             :: skipped is assigned to '_h1' and 'h1_'\n\n) | \n\n( : this group parses a link\n\n  {`[`}~ = _desc, desc_ {`]`}     :: desc (between square brackets)\n  {`(`}~ = _url, url_ {`)`}       :: url, follows [desc] in parens\n\n)=_link, link_ |\n\n\n\n( : this group matches backtick quotations\n\n  ({`\\``}[!`\\``]+{`\\``})=t1                        | :: match single backticked quotes\n  ({`\\``}{`\\``}[!`\\``]+{`\\``}{`\\``})=t2            | :: match double backticked quotes\n  ({`\\``}{`\\``}{`\\``}[!`\\``]+{`\\``}{`\\``}{`\\``})=t3  :: match triple backticked quotes\n\n) = _code, code_    ",
    "args": "tokens, obj",
    "callback": "var {\n  _hashes,  hashes_, \n  _h1, h1_, \n  _desc, desc_, \n  _url, url_, \n  _link, link_,\n  _code, code_,\n  t1, t2, t3,\n} = obj;\n\nconsole.log('\\n');\nconsole.log(obj);\n\nif (_hashes !== undefined) {\n  var hLevel = 1 + hashes_ - _hashes;\n  var header = '';\n  for (var i = _h1; i <= h1_; ++i) {\n    var t = tokens[i];\n    header += t.value;\n  }\n  for (var i = _hashes; i <= h1_; ++i) {\n    tokens[i].value = '';\n  }\n\n  console.log('h1:', [hLevel, header]);\n  var html = '<h'+hLevel+'>'+header+'</h'+hLevel+'>';\n  console.log(' ->', html);\n  tokens[_hashes].value = html;\n}\n\nif (_link !== undefined && link_ !== undefined) {\n  var desc = '';\n  for (var i = _desc; i <= desc_; ++i) {\n    var t = tokens[i];\n    // note: last token is `]` so dont include that\n    if (i !== desc_) desc += t.value;\n  }\n  var url = '';\n  for (var i = _url; i <= url_; ++i) {\n    var t = tokens[i];\n    // note: last token is `]` so dont include that\n    if (i !== url_) url += t.value;\n  }\n  for (var i = _link; i <= link_; ++i) {\n    var t = tokens[i];\n    t.value = '';\n  }\n  console.log('link:', [url, desc]);\n  var html = '<a href=\"'+url+'\">'+desc+'</a>';\n  console.log(' -->', html);\n  tokens[_link].value = html;\n}\n\nif (_code !== undefined && code_ !== undefined) {\n  var code = '';\n  for (var i = _code; i <= code_; ++i) {\n    var t = tokens[i];\n    code += t.value;\n    t.value = '';\n  }\n  code = code.slice(t1?1:t2?2:3, -(t1?1:t2?2:3));\n  console.log('code:', [t1, t2, t3, code]);\n  if (t1 >= 0 || t2 >= 0) {\n    var html = '<code>' + code + '</code>';\n  } else {\n    var html = '<pre>' + code + '</pre>';\n  }\n  console.log(' -->', html);\n  tokens[_code].value = html;\n}",
    "input": "# Example\n\nLet's take a look at some examples.\n\n## Part one\n\nIn this example, running grunt `concat:dist` will first strip any preexisting banner comment from the [src/project.js](http://localhost/project.js) file, then concatenate the result with a newly-generated banner comment, writing the output to `dist/built.js`.\n            ",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // Macros \"shadow\" constants. Uses Drew syntax.\n\n  IS_BLACK: '!IS_WHITE', // see constants\n  IS_WHITE: '` ` | `\\t` | IS_NEWLINE',\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  IS_NEWLINE: 'LF | CR', // you can recurse\n})\n",
    "constants": "({\n  // No constants used in this example\n})\n"
  },
  "MD code": {
    "name": "MD code",
    "lang": "txt",
    "repeatMode": "after",
    "curryTokens": "curry-yes",
    "tokenMode": "index",
    "verboseMode": "verbose-med",
    "query": "( : this group matches backtick quotations\n  ({`\\``}[!`\\``]+{`\\``})=t1                        | :: match single backticked quotes\n  ({`\\``}{`\\``}[!`\\``]+{`\\``}{`\\``})=t2            | :: match double backticked quotes\n  ({`\\``}{`\\``}{`\\``}[!`\\``]+{`\\``}{`\\``}{`\\``})=t3  :: match double backticked quotes\n) = _code, code_                                     :: assign whatever was quoted to code arg\n\n:: another way would be something like this:\n:: {`\\``}({`\\``}({`\\``}[!`\\``]+{`\\``}{`\\``}{`\\``})|[!`\\``]+{`\\``}{`\\``})|[!`\\``]+{`\\``}",
    "args": "tokens, obj",
    "callback": "var {\n  _code, code_,\n  t1, t2, t3,\n} = obj;\n\nconsole.log('\\n');\nconsole.log(obj);\n\nvar code = '';\nfor (var i = _code; i <= code_; ++i) {\n  var t = tokens[i];\n  code += t.value;\n  t.value = '';\n}\ncode = code.slice(t1?1:t2?2:3, -(t1?1:t2?2:3));\nconsole.log('code:', [t1, t2, t3, code]);\nif (t1 >= 0 || t2 >= 0) {\n  var html = '<code>' + code + '</code>';\n} else {\n  var html = '<pre>' + code + '</pre>';\n}\nconsole.log(' -->', html);\ntokens[_code].value = html;",
    "input": "grunt `concat:dist` will ",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // Macros \"shadow\" constants. Uses Drew syntax.\n\n  IS_BLACK: '!IS_WHITE', // see constants\n  IS_WHITE: '` ` | `\\t` | IS_NEWLINE',\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  IS_NEWLINE: 'LF | CR', // you can recurse\n})\n",
    "constants": "({\n  // No constants used in this example\n})\n"
  },
  "MD header": {
    "name": "MD header",
    "lang": "txt",
    "repeatMode": "after",
    "curryTokens": "curry-yes",
    "tokenMode": "index",
    "verboseMode": "verbose-med",
    "query": " ^{`#`}+ = _hashes, hashes_ :: match lines starting with a hash and\n                            :: assign the range of consecutive hashes\n                            :: to '_hashes' and '_hashes_'\n\n [` ` | `\\t`]*              :: skip tabs and spaces between hashes \n                            :: and content\n\n ~=_h1, h1_ $               :: ~ will skip until $ matches, which is \n                            :: end of line/file. the range being \n                            :: skipped is assigned to '_h1' and 'h1_'",
    "args": "tokens, obj",
    "callback": "var {\n  _hashes,  hashes_, \n  _h1, h1_, \n} = obj;\n\nconsole.log('\\n');\nconsole.log(obj);\n\nvar hLevel = 1 + hashes_ - _hashes;\nvar header = '';\nfor (var i = _h1; i <= h1_; ++i) {\n  var t = tokens[i];\n  header += t.value;\n}\nfor (var i = _hashes; i <= h1_; ++i) {\n  tokens[i].value = '';\n}\n\nconsole.log('h1:', [hLevel, header]);\nvar html = '<h'+hLevel+'>'+header+'</h'+hLevel+'>';\nconsole.log(' ->', html);\ntokens[_hashes].value = html;",
    "input": "# Example\n\nThis will be the example\n\n## Part 1\n\nThe rest goes here",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // Macros \"shadow\" constants. Uses Drew syntax.\n\n  IS_BLACK: '!IS_WHITE', // see constants\n  IS_WHITE: '` ` | `\\t` | IS_NEWLINE',\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  IS_NEWLINE: 'LF | CR', // you can recurse\n})\n",
    "constants": "({\n  // No constants used in this example\n})\n"
  },
  "MD links": {
    "name": "MD links",
    "lang": "txt",
    "repeatMode": "after",
    "curryTokens": "curry-yes",
    "tokenMode": "index",
    "verboseMode": "verbose-med",
    "query": "(\n  {`[`}~=_desc, desc_ {`]`}          :: desc (between square brackets)\n  {`(`}~=_url, url_ {`)`}            :: url, follows [desc] in parens\n)=_link, link_\n",
    "args": "tokens, obj",
    "callback": "var {\n  _hashes,  hashes_, \n  _h1, h1_, \n  _desc, desc_, \n  _url, url_, \n  _link, link_,\n  _code, code_,\n  t1, t2, t3,\n} = obj;\n\nconsole.log('\\n');\nconsole.log(obj);\n\nif (_hashes !== undefined) {\n  var hLevel = 1 + hashes_ - _hashes;\n  var header = '';\n  for (var i = _h1; i <= h1_; ++i) {\n    var t = tokens[i];\n    header += t.value;\n    t.value = '';\n  }\n  console.log('h1:', [hLevel, header]);\n  var html = '<h'+hLevel+'>'+header+'</h'+hLevel+'>';\n  console.log(' ->', html);\n  tokens[_hashes].value = html;\n}\n\nif (_link !== undefined && link_ !== undefined) {\n  var desc = '';\n  for (var i = _desc; i <= desc_; ++i) {\n    var t = tokens[i];\n    // note: last token is `]` so dont include that\n    if (i !== desc_) desc += t.value;\n  }\n  var url = '';\n  for (var i = _url; i <= url_; ++i) {\n    var t = tokens[i];\n    // note: last token is `]` so dont include that\n    if (i !== url_) url += t.value;\n  }\n  for (var i = _link; i <= link_; ++i) {\n    var t = tokens[i];\n    t.value = '';\n  }\n  console.log('link:', [url, desc]);\n  var html = '<a href=\"'+url+'\">'+desc+'</a>';\n  console.log(' -->', html);\n  tokens[_link].value = html;\n}\n\nif (_code !== undefined && code_ !== undefined) {\n  var code = '';\n  for (var i = _code; i <= code_; ++i) {\n    var t = tokens[i];\n    code += t.value;\n    t.value = '';\n  }\n  code = code.slice(t1?1:t2?2:3, -(t1?1:t2?2:3));\n  console.log('code:', [t1, t2, t3, code]);\n  if (t1 >= 0 || t2 >= 0) {\n    var html = '<code>' + code + '</code>';\n  } else {\n    var html = '<pre>' + code + '</pre>';\n  }\n  console.log(' -->', html);\n  tokens[_code].value = html;\n}",
    "input": "the [src/project.js](http://localhost/project.js) file\n",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // Macros \"shadow\" constants. Uses Drew syntax.\n\n  IS_BLACK: '!IS_WHITE', // see constants\n  IS_WHITE: '` ` | `\\t` | IS_NEWLINE',\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  IS_NEWLINE: 'LF | CR', // you can recurse\n})\n",
    "constants": "({\n  // No constants used in this example\n})\n"
  },
  "Repeat": {
    "name": "Repeat",
    "lang": "txt",
    "repeatMode": "after",
    "curryTokens": "curry-no",
    "tokenMode": "object",
    "verboseMode": "verbose-med",
    "query": "(\n  {`f`i}                 :: case sensitive flag\n  {`o`}{`o`}\n) = 0: first, 1: last    :: so match foo/Foo and pass on the \n                         :: first/last token of the whole match\n                         :: as argument one and two of the callback\n                         :: (the `: first` part is just a comment)",
    "args": "start, stop",
    "callback": "console.log(start, stop);\n\nstart.value = '0';\nstop.value = '1';",
    "input": "FooBarFooBar",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // Macros \"shadow\" constants. Uses Drew syntax.\n\n  IS_BLACK: '!IS_WHITE', // see constants\n  IS_WHITE: '` ` | `\\t` | IS_NEWLINE',\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  IS_NEWLINE: 'LF | CR', // you can recurse\n})\n",
    "constants": "({\n  // No constants used in this example\n})\n"
  },
  "Tab test": {
    "name": "Tab test",
    "lang": "txt",
    "repeatMode": "after",
    "curryTokens": "curry-yes",
    "tokenMode": "index",
    "verboseMode": "verbose-med",
    "query": "[`a`][`\\t`]=yes[`b`]",
    "args": "tokens, obj",
    "callback": "console.log(obj.yes);\n\ntokens[obj.yes].value = 'FOUND';",
    "input": "a\tb",
    "macros": "({\n  // Cached matching conditions. Some are\n  // lang. dep. and used by Drew internally.\n  // Macros \"shadow\" constants. Uses Drew syntax.\n\n  IS_BLACK: '!IS_WHITE', // see constants\n  IS_WHITE: '` ` | `\\t` | IS_NEWLINE',\n  LF: '`\\\\x0A`', // \\n\n  CR: '`\\\\x0D`', // \\r\n  IS_NEWLINE: 'LF | CR', // you can recurse\n})\n",
    "constants": "({\n  // No constants used in this example\n})\n"
  },
  "CSS": {
    "name": "CSS",
    "lang": "css",
    "repeatMode": "after",
    "curryTokens": "curry-no",
    "tokenMode": "object",
    "verboseMode": "verbose-med",
    "query": "[IS_NEWLINE]",
    "args": "newline",
    "callback": "console.log(newline);\nnewline.value = '/* nl */';",
    "input": ".foo { \n  width: 15px; \n  height: 200%; \n}",
    "macros": "({\n  IS_BLACK: '!WHITE', // see constants\n})\n            ",
    "constants": "({\n  WHITE: 'current().type === Constants.TOKEN_WHITESPACE',\n  IS_NEWLINE: 'current().type === Constants.TOKEN_NEWLINE',\n})\n            "
  }
};
