var consoleExamples = [
  {
    desc: 'clear',
  },
  {
    desc: 'fix c style curlies',
    query: '{`if` | `while`} {PAREN_PAIR}=,0 (~ [NEWLINE])=2,3 {`{`}=,1',
    input: 'if (foo)\n{\n  bar;\n}\n\nwhile (have)\n{\n  weird()\n}',
    handlerargs: 'parenStop, curlyOpen, whiteStart, whiteStop',
    handler: "document.querySelector('#debug').value += 'callback called with '+arguments.length+' arguments\\n\\n';\n\nparenStop.value += ' {';\ncurlyOpen.value = '';\nwhiteStart.value = '';\nwhiteStop.value = '';",
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'complex: remove console stuff and useless blocks',
    query: '(({`!`}{`void`})?{`console`}{`.`}{`log`|`warn`|`group`|`groupEnd`|`error`}{PAREN_PAIR}({`&&`}|{`||`}|{`;`}|{`,`})?)=0,1|({`;`}{CURLY_PAIR}=2,3)|[COMMENT]=2,3|(([NEWLINE][!NEWLINE & WHITE]*)=0,1[NEWLINE]): find console expressions, perhaps with `!void` and trailing comma or semi, and blocks that follow semi colons',
    input: 'function query() {\n  // input query: [`b`][`;`]~$$\n  // final query: [`b`][`;`]~$$\n  // query start..\n  var group0 = false;\n  matchedSomething = false;\n  console.group("root start");\n  { // parseAtomMaybe 1 for a white token `[`\n      // white token 1:0\n      group0 = checkTokenWhite(symw() && !void console.log("# 1001 start of literal [`b`] at 4 in query to token " + index + ":", token()) && value(\'b\'));\n  } // `]` 1 for a white token\n\n  if (group0)\n  // white token 2:1\n      group0 = checkTokenWhite(symw() && !void console.log("# 1002 start of literal [`;`] at 9 in query to token " + index + ":", token()) && value(\';\'));\n\n  if (group0)\n  // dont seek for leading ~, just wait for a non-spacy token\n      if (console.log("~ seek() past spaces and tabs at all?", matchedSomething, "start=", index), matchedSomething) {\n          if (isSpaceTabComment()) {\n              console.log("~ skipping spaces and tabs");\n              do ++index;\n              while (isSpaceTabComment()); // ~\n          }\n          group0 = !isWhite(); // if current is white now, seek failed\n          console.log(group0 ? "~ passed" : "~ failed", index);\n      }\n\n  if (group0)\n      console.log("$$ end of file?", index >= tokens.length), (group0 = (index >= tokens.length)); // $$\n  (matchedSomething = true);\n\n  console.groupEnd();\n\n  // query end..\n  return group0;\n}\n   ',
    handlerargs: 'cleanStart, cleanStop, curlyOpen, curlyClose',
    handler: 'try {\n  document.querySelector(\'#debug\').value += \'match callback: \'+arguments.length+\': \'+JSON.stringify([].slice.call(arguments, 0))+\'\\n\\n\';\n} catch (e) {\n  document.querySelector(\'#debug\').value += \'match callback: \'+arguments.length+\': (json stringify failed)\';\n}\n\n// the block is assigned to third and fourth arg, if they exist, only remove them and nothing in between\nif (curlyOpen && curlyClose) {\n  curlyOpen.value = \'\';\n  curlyClose.value = \'\';\n  // it was a match, not a block, so must be a console expression. remove the whole range\n} else if (cleanStart && cleanStop) {\n  for (var i=cleanStart.white; i<=cleanStop.white; ++i) {\n    TOKENS.whites[i].value = \'\';\n  }\n}\n',
    repeat: 'every',
    copy: 'copy',
  },
  {
    desc: 'match parens',
    query: '{PAREN_PAIR}=0,1',
    input: 'switch (x) {\n  case a: break;\n  case \'x\': break;\n  case 15: \n    break;\n  case false\n  : break;\n  case\n  null: break;\n  default:\n  floop;\n}',
    handlerargs: 'match1, match2',
    handler: 'document.querySelector(\'#debug\').value += \'callback called with \'+arguments.length+\' arguments\\n\\n\';\n\nmatch1.value = \'#\';\nmatch2.value = \'#\'',
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'match curlies',
    query: '{CURLY_PAIR}=0,1',
    input: 'switch (x) {\n  case a: break;\n  case \'x\': break;\n  case 15: \n    break;\n  case false\n  : break;\n  case\n  null: break;\n  default:\n  floop;\n}',
    handlerargs: 'match1, match2',
    handler: 'document.querySelector(\'#debug\').value += \'callback called with \'+arguments.length+\' arguments\\n\\n\';\n\nmatch1.value = \'#\';\nmatch2.value = \'#\'',
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'match simple cases',
    query: '{`case`}=0 {STRING|IDENTIFIER|NUMBER}=1:this is a single token condition but could be any expression {`:`}=2',
    input: 'switch (x) {\n  case a: break;\n  case \'x\': break;\n  case 15: \n    break;\n  case false\n  : break;\n  case\n  null: break;\n  default:\n  floop;\n}',
    handlerargs: 'casekeyword, condition, colon',
    handler: 'document.querySelector(\'#debug\').value += \'callback called with \'+arguments.length+\' arguments\\n\\n\';\n\ncasekeyword.value = \'#\';\ncondition.value = \'$\';\ncolon.value = \'%\';',
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'macro example ADDITION',
    query: '(ADDITION) = , 1 : note that 0 is implied to the start unless overriden',
    input: 'var x = 1 + 2 - 3 + 4;',
    handlerargs: 'a, b',
    handler: 'document.querySelector(\'#debug\').value += \'callback called with \'+arguments.length+\' arguments\\n\\n\';\n\na.value = \'#\';\nb.value = \'$\';',
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'eliminate LOGs from generated content',
    query: '(({`&&`}{`!`}{`void`}{`LOG`}{PAREN_PAIR})  |  ({`LOG`}|{`GROPEN`}|{`GRCLOSE`}){PAREN_PAIR}{`;`})=0,1',
    input: 'function query(){\n  // input query: {PAREN_PAIR}=0,1\n  // final query: {(`(`& JUMP_TO_RHP)}=0,1\n  // query start..\nvar group0 = false;\nmatchedSomething = false;\nGROPEN("root start");\n{\n\n//#parseAtomMaybe (parsed `{(`(`& JUMP_TO_RHP)}=0,1`)\n// - its a black token\n{\nmatchedSomething = true;\n{ // parseAtomMaybe 1 for black token `{`\n// black token 1:0\ngroup0 = checkTokenBlack(symb() && !void LOG("# 1001 start of symbol [PAREN_PAIR] at 11 in query to token "+index+":", token())\n//#parseAtomMaybe (parsed `(`(`& JUMP_TO_RHP)`)\n// - its a _nested_ group\n&& (matchedSomething = true) && checkConditionGroup(symgc()// parseGroup, first=false\n && !void LOG("# 1002 start of symbol [PAREN_OPEN] at 13 in query to token "+index+":", token()) && (true && !void LOG("# 1003 start of literal [`%o`] at 5 in query to token "+index+":", "(", token()) && is(\'(\') && (true && !void LOG("# 1004 start of symbol [JUMP_TO_RHP] at 18 in query to token "+index+":", token()) && (token().rhp && skipTo(token().rhp.white)))))// parseAtomMaybe end\n, \'0\', \'1\');\n} // `}` 1 for black token\n}\n// parseAtomMaybe end\n\nGRCLOSE();\n}\n\n  // query end..\n  return group0;\n}\n',
    handlerargs: 'a, b',
    handler: 'document.querySelector(\'#debug\').value += \'callback called with \'+arguments.length+\' arguments\\n\\n\';\n\nfor (var i=a.white; i<=b.white; ++i) {\n  TOKENS.whites[i].value = \'\';\n}',
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'eliminate comments from generated content',
    query: '[WHITE & /^\\//] : silly only because zeparser outputs comment tokens as white for simplicity, well where is your simplicity now eh',
    input: '// this is after the "eliminate LOGs from generated content" example ran:\nfunction query(){\n  // input query: {PAREN_PAIR}=0,1\n  // final query: {(`(`& JUMP_TO_RHP)}=0,1\n  // query start..\nvar group0 = false;\nmatchedSomething = false;\n\n{\n\n//#parseAtomMaybe (parsed `{(`(`& JUMP_TO_RHP)}=0,1`)\n// - its a black token\n{\nmatchedSomething = true;\n{ // parseAtomMaybe 1 for black token `{`\n// black token 1:0\ngroup0 = checkTokenBlack(symb() \n//#parseAtomMaybe (parsed `(`(`& JUMP_TO_RHP)`)\n// - its a _nested_ group\n&& (matchedSomething = true) && checkConditionGroup(symgc()// parseGroup, first=false\n  && (true  && is(\'(\') && (true  && (token().rhp && skipTo(token().rhp.white)))))// parseAtomMaybe end\n, \'0\', \'1\');\n} // `}` 1 for black token\n}\n// parseAtomMaybe end\n\n\n}\n\n  // query end..\n  return group0;\n}\n',
    handlerargs: 'a',
    handler: 'document.querySelector(\'#debug\').value += \'callback called with \'+arguments.length+\' arguments\\n\\n\';\n\na.value = \'\';\n',
    repeat: 'after',
    copy: 'nocopy',
  },
  {
    desc: 'cleanup artifacts afterwards',
    query: '({`{`|`;`}{CURLY_PAIR}=0,1) :eliminate empty blocks | ([NEWLINE]~[NEWLINE])=2,3 : eliminate empty lines, the tilde skips all non-newline whites, make sure 3 is not the last newline so one newline survives',
    input: '// result after comment elimination example\nfunction query(){\n  \n  \n  \nvar group0 = false;\nmatchedSomething = false;\n\n{\n\n\n\n{\nmatchedSomething = true;\n{ \n\ngroup0 = checkTokenBlack(symb() \n\n\n&& (matchedSomething = true) && checkConditionGroup(symgc()\n  && (true  && is(\'(\') && (true  && (token().rhp && skipTo(token().rhp.white)))))\n, \'0\', \'1\');\n} \n}\n\n\n\n}\n\n  \n  return group0;\n}\n',
    handlerargs: 'a,b,c,d',
    handler: '\nif (a && b) {\ndocument.querySelector(\'#debug\').value += \'block called with \'+arguments.length+\' arguments\\n\\n\';\n  a.value = \'\';\n  b.value = \'\';\n}\n\n\nif (c && d) {\n  document.querySelector(\'#debug\').value += \'empty line called with \'+arguments.length+\' arguments\\n\\n\';\n  for (var i=c.white; i<=d.white; ++i) TOKENS.whites[i].value = \'\';\n}',
    repeat: 'every',
    copy: 'copy',
  },
];

consoleExamplesBak = consoleExamples.slice(0);
